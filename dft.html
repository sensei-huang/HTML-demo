<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>DFT Dot Product Sum Visualizer</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"></script>
<style>
  body { font-family: sans-serif; padding: 20px; background: #f8f8f8; }
  canvas { border: 1px solid #ccc; background: white; display: block; margin-bottom: 20px; }
  label { display: block; margin-top: 10px; }
  .value { font-weight: bold; }
</style>
</head>
<body>

<h2>DFT Dot Product Sum Visualizer</h2>
<p>
Adjust the signal frequency, phase, and DFT bin. 
Both Re (cos) and Im (sin) dot products are visible</p>


<label>Signal Frequency:
  <input type="range" id="freqSlider" min="0" max="8" step="0.1" value="3">
</label>

<label>Signal Phase:
  <input type="range" id="phaseSlider" min="0" max="6.28" step="0.05" value="0">
</label>

<label>DFT Bin k:
  <input type="range" id="kSlider" min="0" max="8" step="1" value="3">
</label>

<p>
In this box, black is the signal while red is sin and blue is cos.
</p>
<canvas id="signalCanvas" width="600" height="180"></canvas>
<p>
In the second box, red is the dot product of sin and the signal while blue is the dot product of cos and the signal.
</p>
<canvas id="productCanvas" width="600" height="180"></canvas>
<p>

<div id="formula"></div>


<script>
const N = 64;

// Draw wave with zero line
function drawWaveWithZero(ctx, arrList, colorList, offsetList) {
  const midY = ctx.canvas.height/2;
  ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);

  // Zero line
  ctx.strokeStyle="#555";
  ctx.beginPath();
  ctx.moveTo(0, midY);
  ctx.lineTo(ctx.canvas.width, midY);
  ctx.stroke();

  // Draw each wave
  for(let w=0; w<arrList.length; w++){
    const arr = arrList[w];
    const color = colorList[w];
    const offset = offsetList[w] || 0;

    ctx.strokeStyle=color;
    ctx.beginPath();
    for(let i=0;i<arr.length;i++){
      let x = (i/N)*ctx.canvas.width;
      let y = midY + offset - arr[i]*60;
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
}

// Draw multiple shaded waves
function drawWaveShaded(ctx, arrList, colorList) {
  const canvasHeight = ctx.canvas.height;
  const midY = canvasHeight / 2;
  ctx.clearRect(0,0,ctx.canvas.width,canvasHeight);

  // Zero line
  ctx.strokeStyle="#555";
  ctx.beginPath();
  ctx.moveTo(0, midY);
  ctx.lineTo(ctx.canvas.width, midY);
  ctx.stroke();

  for(let w=0; w<arrList.length; w++){
    const arr = arrList[w];
    const color = colorList[w];
    const maxVal = Math.max(...arr.map(Math.abs)) || 1;

    // Wave line
    ctx.beginPath();
    for(let i=0;i<arr.length;i++){
      let x = (i/N)*ctx.canvas.width;
      let y = midY - (arr[i]/maxVal)*(midY-10);
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.strokeStyle=color;
    ctx.stroke();

    // Shading
    ctx.globalAlpha=0.2;
    for(let i=0;i<arr.length-1;i++){
      let x1=(i/N)*ctx.canvas.width;
      let x2=((i+1)/N)*ctx.canvas.width;
      let y1=midY-(arr[i]/maxVal)*(midY-10);
      let y2=midY-(arr[i+1]/maxVal)*(midY-10);

      ctx.beginPath();
      ctx.moveTo(x1, midY);
      ctx.lineTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.lineTo(x2, midY);
      ctx.closePath();
      ctx.fillStyle = arr[i]>=0 ? "green" : "red";
      ctx.fill();
    }
    ctx.globalAlpha=1.0;
  }
}

function update(){
  const freq=parseFloat(freqSlider.value);
  const phase=parseFloat(phaseSlider.value);
  const k=parseInt(kSlider.value);

  // Signal & basis
  let signal=[], cosk=[], sink=[];
  for(let n=0;n<N;n++){
    signal.push(Math.sin(2*Math.PI*freq*n/N+phase));
    cosk.push(Math.cos(2*Math.PI*k*n/N));
    sink.push(Math.sin(2*Math.PI*k*n/N));
  }

  // Dot products
  let xcos=[], xsin=[];
  for(let n=0;n<N;n++){
    xcos.push(signal[n]*cosk[n]);
    xsin.push(-signal[n]*sink[n]);
  }

  // Cumulative sums
  let ReAccum=[], ImAccum=[];
  let ReSum=0, ImSum=0;
  for(let n=0;n<N;n++){
    ReSum+=xcos[n];
    ImSum+=xsin[n];
    ReAccum.push(ReSum);
    ImAccum.push(ImSum);
  }

  let finalMag = Math.sqrt(ReSum*ReSum + ImSum*ImSum);

  // Draw top: signal, cos, sin
  let ctx1 = signalCanvas.getContext("2d");
  drawWaveWithZero(ctx1,[signal, cosk, sink],["black","blue","red"],[0,-40,40]);

  // Draw dot product waves: both xcos and xsin
  let ctx2 = productCanvas.getContext("2d");
  drawWaveShaded(ctx2,[xcos,xsin],["blue","red"]);

  // Dynamic formula
  let formulaDiv = document.getElementById("formula");
  formulaDiv.innerHTML="";
  katex.render(`
    \\begin{aligned}
      X[${k}] &= \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi ${k} n / N} \\\\
              &= \\sum_{n=0}^{N-1} x[n]\\cos\\frac{2\\pi ${k} n}{N} - i \\sum_{n=0}^{N-1} x[n]\\sin\\frac{2\\pi ${k} n}{N} \\\\
              &= {\\color{blue}{${ReSum.toFixed(2)}}} - ({\\color{red}{${ImSum.toFixed(2)}}})i \\\\
      \\underline{|X[${k}]| = ${finalMag.toFixed(2)}|}
    \\end{aligned}
  `, formulaDiv,{displayMode:true});
}

// Event listeners
const freqSlider=document.getElementById("freqSlider");
const phaseSlider=document.getElementById("phaseSlider");
const kSlider=document.getElementById("kSlider");
freqSlider.oninput=update;
phaseSlider.oninput=update;
kSlider.oninput=update;

update();

</script>

</body>
</html>
